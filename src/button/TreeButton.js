/**
 * Created by JPeruggia on 03/07/2016.
 */
Ext.define('Ext.button.TreeButton', {
    extend: 'Ext.button.Split',
    xtype: 'treebutton',
    requires: [
        'Ext.data.TreeStore',
        'Ext.tree.Panel'
    ],


    config: {
        /**
         * @cfg parentScrollPanel
         * scroll fix component.
         */
        parentScrollPanel: null,

        value: null,
        /**
         * @cfg {String} pickerUI
         * The UI to use in the picker generated by the button
         */
        pickerUI: 'default',
        /**
         * @cofg {String} darkUI
         *  The UI used when there a    re items selected in the picker.
         */
        darkUI: 'default',
        /**
         * @cofg {String} lightUI
         *  The UI used when there are items selected in the picker.
         */
        lightUI: 'default',
        /**
         * @cofg {String} darkestUI
         *  The UI used when there are items selected in the picker.
         */
        darkestUI: 'default',
        /**
         * @cfg {Number} minPickerWidth [minPickerWidth=200]
         * this config allows you to set the min width for the picker displayed
         */
        minPickerWidth: 325,
        /**
         * @cfg {Number} maxPickerWidth [maxPickerWidth=200]
         * this config allows you to set the max width for the picker displayed
         */
        maxPickerWidth: 325,
        /**
         * @cfg {Number} minPickerHeight [minPickerHeight=200]
         * this config allows you to set the min height for the picker displayed
         */
        minPickerHeight: 250,
        /**
         * @cfg {Number} maxPickerHeight [maxPickerHeight=200]
         * this config allows you to set the max height for the picker displayed
         */
        maxPickerHeight: 250,

        /**
         * @cfg {Boolean} allowSplit { allowSplit = false}
         * this config allows you to enable the split button functionality if needed.
         */
        allowSplit: false,

        store: Ext.create('Ext.data.TreeStore')
    },

    initComponent:function(){
        var me = this;
        me.callParent(arguments);
        me.createPicker(); // create the picker for the button.
        me.defaultUI = me.ui;
        me.mon(me.store, {
            scope: me,
            load: me.onLoad,
            update: me.onUpdate
        });

    },


    /**
     * @method updateUI
     * will update the buttons ui to match the values that are checked / selected.
     */
    updateUI: function(){
        var me = this;
        if (me.getSelectedValues().length == 1 && this.value == me.getSelectedValues()[0] && this.allowSplit){
            me.setUI(me.lightUI);
        }else if (me.getChecked().length > 0){
            if (me.allowSplit == true)
                me.value = me.store.getRoot().get('id');
            me.setUI(me.darkUI);
        }else{
            me.setUI(me.defaultUI)
        }
    },

    /**
     * @private Handler Event setup when the button is configured to allowSplit. This will 
     * allow the button to have a "top" level selected and update the styles. 
      */
    handler: function(){
        var store = this.getStore(),
            buttonRootId = store.getRoot().get('id'),
            beforeSelectionValues = this.getSelectedValues();
        
        // if nothing is checked make it light green set this.value
        if (beforeSelectionValues.length == 0 && this.value == null && this.allowSplit){
            this.value = buttonRootId;
            this.setUI(this.lightUI);
        }else if (beforeSelectionValues.length > 0 || this.value != null || this.allowSplit == false){
            // there are things checked, uncheck them all and clear the values.
            this.clearValues();
        }
    },

    /**
     * @method clearValues
     * clears all selected values from the picker checkbox.
     */
    clearValues:function(){

        function removeChecks(node){
            node.beginEdit();
            node.set('checked', false);
            node.childNodes.forEach(function(childNode){
                removeChecks(childNode);
            });
            node.endEdit();
        }

        var pickerStore = this.picker.getStore();
        pickerStore.each(function(node){
           removeChecks(node);
        });
        this.value = null
        this.setUI(this.defaultUI);
    },

    /**
     * @event Click
     * Fires same event as arrow handler in these components.
     */
    onClick: function(e){
        var me = this,
            arrowKeydown = e.type === 'keydown' && e.target === me.arrowEl.dom;

        me.doPreventDefault(e);

        if (!me.disabled) {
            if (!this.allowSplit) {
                this.arrowHandler();
                return;
            }

            if (arrowKeydown || me.isWithinTrigger(e)) {
                // Force prevent default here, if we click on the arrow part
                // we want to trigger the menu, not any link if we have it
                e.preventDefault();
                me.maybeShowMenu(e);
                me.fireEvent("arrowclick", me, e);
                if (me.arrowHandler) {
                    me.arrowHandler.call(me.scope || me, me, e);
                }
            } else {
                me.doToggle();
                me.fireHandler(e);
            }
        }

    },

    /**
     * @event arrowHandler
     * shows picker below button, with slight offset if at edge of the browser window.
     */
    arrowHandler:function(){
        var me =this,
            picker = me.picker;

        if (me.getStore() == null || me.getStore().count() < 1){
            Ext.Msg.alert("Warning", "There are no tags for this button.");
            return;
        }

        // when the arrow handler is fired, make sure we don't mess up the scroll position.
        if(me.parentScrollPanel)
            var scrollPosition = me.parentScrollPanel.el.cacheScrollValues();
        //picker.showAt(me.getEl().getX(), me.getEl().getY() + me.getEl().getHeight());

        picker.showBy(me.getEl(), me.menuAlign);
        picker.alignTo(me, me.menuAlign);
        if(me.parentScrollPanel)
            scrollPosition();


    },

    /**
     * @private Creates component picker based on the tree store.
     */
    createPicker: function(){
        var me = this;
        // if button doesn't have a picker yet, lets make it.
        if (!me.picker){
            me.picker = new Ext.tree.Panel({
                baseCls: Ext.baseCSSPrefix + 'boundlist',
                shrinkWrapDock: 2,
                ui: me.pickerUI,
                store: me.store,
                floating: true,
                displayField: me.displayField,
                columns: me.columns,
                minWidth: me.minPickerWidth,
                maxWidth: me.maxPickerWidth,
                minHeight: me.minPickerHeight,
                maxHeight: me.maxPickerHeight,
                tabIndex: 1,
                shadow: true,
                scrollable: 'vertical',
                disableSelection: true,
                rootVisible: false,
                listeners: {
                    scope: me,
                    focusleave: function(){
                        var scrollPosition = null;
                        me.picker.hide();
                        if(me.parentScrollPanel)
                            scrollPosition = me.parentScrollPanel.el.cacheScrollValues();
                        // after checking off / unchecking see if I have a length. If there is a length set value.
                        if (me.getChecked().length > 0){
                            if (me.allowSplit == true)
                                me.value = me.store.getRoot().get('id');
                            me.setUI(me.darkUI);
                        }else if (me.value == me.store.getRoot().get('id')){
                            me.setUI(me.lightUI);
                        }else{
                            me.setUI(me.defaultUI);
                        }

                        if(me.parentScrollPanel)
                            scrollPosition();

                    },
                    checkchange: function(node){
                        me.picker.focus();
                        if(me.parentScrollPanel) {
                            var scrollPosition = me.parentScrollPanel.el.cacheScrollValues();
                            scrollPosition();
                        }
                    }
                }
            });
        }

        var view = me.picker.getView();
    },


    /**
     * @method Fired when store is updated
     * @param store
     * @param rec
     * @param type
     * @param modifiedFieldNames
     */
    onUpdate: function(store, rec, type, modifiedFieldNames) {
        var display = this.displayField;

        if (type === 'edit' && modifiedFieldNames && Ext.Array.contains(modifiedFieldNames, display) && this.value === rec.getId()) {
            this.setRawValue(rec.get(display));
        }
    },


    /**
     * Handles the store's load event.
     * @private
     */
    onLoad: function() {
        var value = this.value;

        if (value) {
            this.setValue(value);
        }
    },

    /**
     * @method getSelectedValues
     * returns the value of the checked values in the picker.
     */
    getSelectedValues: function(){
        var checkedRecords = this.getChecked();
        var values = [];

        for(var i = 0; i < checkedRecords.length; i++){
            values.push(checkedRecords[i].get(this.valueField))
        }

        if ( this.value != null) {
            values.push(this.value);
        }

        return values;
     },


    /**
     * @method getChecked
     * Method to get the records that are selected in the picker.
     * @returns {*|Ext.data.TreeModel[]}
     */
    getChecked: function(){
        var me = this,
            checkedValues = me.picker.getChecked();

        return checkedValues;
    },

    /**
     * @method getStore
     * Returns the store for the picker.
     * @returns {*}
     */
    getStore: function(){
        return this.store;
    },


    bindStore:function(store){
        var me = this;
            me.picker.bindStore(store);
    },

    /**
     * Override that adds/removes the ui classes to the child elements
     */
    setUI: function (ui) {
        var me = this,
            activeUI = me.activeUI,
            scrollY = null;

        if (me.parentScrollPanel != null){
            scrollY = me.parentScrollPanel.getScrollY();
        }

        if (me.scale && !ui.match(me.scale)) {
            ui = ui + '-' + me.scale;
        }

        if (ui === activeUI) {
            return;
        }

        if (activeUI) {
            if (me.btnEl) {
                me.btnEl.removeCls(me._btnCls + '-' + activeUI);
                me.btnEl.addCls(me._btnCls + '-' + ui);
            }
            if (me.btnIconEl) {
                me.btnIconEl.removeCls(me._baseIconCls + '-' + activeUI);
                me.btnIconEl.addCls(me._baseIconCls + '-' + ui);
            }
            if (me.btnInnerEl) {
                me.btnInnerEl.removeCls(me._innerCls + '-' + activeUI);
                me.btnInnerEl.addCls(me._innerCls + '-' + ui);
            }
            if (me.btnWrap) {
                me.btnWrap.removeCls(me._btnWrapCls + '-' + activeUI);
                me.btnWrap.addCls(me._btnWrapCls + '-' + ui);
            }
        }
        me.callParent([ui]);

        // fix scrolling if needed. 
        if(scrollY != null){
            me.parentScrollPanel.setScrollY(scrollY);
        }
    }
});